#!/bin/bash

# Strict mode
set -e # Exit immediately if a command exits with a non-zero status.
set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.

echo "üöÄ Starting CUM Report installation and setup (using post-commit hook)..."
echo "Script execution started at: $(date)"

# 1. Check if inside a Git repository and get the root directory
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo "‚ùå Error: This script must be run from within a Git repository."
  exit 1
fi
echo "Checkpoint 1: Git repository check passed."

GIT_ROOT=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT" ]; then
    echo "‚ùå Error: Could not determine the root of the Git repository."
    exit 1
fi
echo "‚úÖ Git repository root detected at: $GIT_ROOT"
echo "Checkpoint 2: Git root determined."

# Function to install packages if missing
install_package() {
  local package="$1"
  if ! command -v "$package" &> /dev/null; then
    echo "üîß $package not found. Attempting to install..."
    if command -v apt &> /dev/null; then
      sudo apt update && sudo apt install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v brew &> /dev/null; then
      brew install "$package"
    else
      echo "‚ùå Error: No common package manager (apt, yum, brew) found. Please install $package manually."
      exit 1
    fi

    if ! command -v "$package" &> /dev/null; then
        echo "‚ùå Error installing $package even after attempting. Please install it manually and rerun this script."
        exit 1
    fi
    echo "‚úÖ $package installed successfully."
  else
    echo "üëç $package is already installed."
  fi
}

install_package "jq"
install_package "curl"
echo "Checkpoint 3: Required packages checked/installed."

CUM_REPORT_DIR="$GIT_ROOT/CUM_report"
echo "Checkpoint 4: About to ensure CUM_report directory exists at $CUM_REPORT_DIR."
mkdir -p "$CUM_REPORT_DIR"
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create CUM_report directory at $CUM_REPORT_DIR. Check permissions."
    exit 1
fi
echo "‚úÖ Ensured CUM_report directory exists at: $CUM_REPORT_DIR"
echo "Checkpoint 5: CUM_report directory ensured."

INITIAL_TEX_FILE="$CUM_REPORT_DIR/commit_log.tex"
echo "Checkpoint 6: Checking for initial LaTeX file: $INITIAL_TEX_FILE."
if [ ! -f "$INITIAL_TEX_FILE" ]; then
  echo "üìÑ Creating initial LaTeX file: $INITIAL_TEX_FILE"
  cat <<EOF > "$INITIAL_TEX_FILE"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{courier} % For pcr font family

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit and included herein.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each section corresponds to a summary generated at the time of a commit.
The summaries are generated by an AI model based on the diff of the commit.

\\end{document}
EOF
  if [ $? -ne 0 ]; then
    echo "‚ùå Error: Failed to create initial LaTeX file at $INITIAL_TEX_FILE."
    exit 1
  fi
  echo "‚úÖ Initial LaTeX file created: $INITIAL_TEX_FILE"
else
  echo "üëç Initial LaTeX file already exists: $INITIAL_TEX_FILE"
fi
echo "Checkpoint 7: Initial LaTeX file status checked/created."

# 4. Define and install the post-commit hook
HOOK_PATH="$GIT_ROOT/.git/hooks/post-commit"
HOOK_DIR_PATH=$(dirname "$HOOK_PATH")

# Remove old pre-push hook if it exists from previous installations of this tool
OLD_PRE_PUSH_HOOK_PATH="$GIT_ROOT/.git/hooks/pre-push"
if [ -f "$OLD_PRE_PUSH_HOOK_PATH" ]; then
    if grep -q "CUM pre-push hook" "$OLD_PRE_PUSH_HOOK_PATH"; then # Simple check
        echo "‚ÑπÔ∏è Removing old CUM pre-push hook at $OLD_PRE_PUSH_HOOK_PATH."
        rm -f "$OLD_PRE_PUSH_HOOK_PATH"
    fi
fi

echo "‚öôÔ∏è  Attempting to install post-commit hook to: $HOOK_PATH"
echo "Checkpoint 8: About to create hook directory $HOOK_DIR_PATH."
mkdir -p "$HOOK_DIR_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to create hook directory at $HOOK_DIR_PATH. Check permissions."
    exit 1
fi
echo "‚úÖ Hook directory ensured/created at $HOOK_DIR_PATH."
echo "Checkpoint 9: Hook directory creation attempt finished."

echo "Checkpoint 10: About to write post-commit hook content to $HOOK_PATH."
cat << 'HOOK_SCRIPT_EOF' > "$HOOK_PATH"
#!/bin/bash

# Prevent the hook from running when we are amending the commit from within this hook
if [ "$GIT_CUM_REPORT_AMENDING_COMMIT" = "true" ]; then
  exit 0
fi

# Hook script strict mode
set -e
set -o pipefail

echo "üî• Running CUM post-commit hook..."

GIT_ROOT_DIR=$(git rev-parse --show-toplevel)
if [ -z "$GIT_ROOT_DIR" ]; then
    echo "‚ùå Hook Error: Could not determine Git root directory. Aborting hook." >&2
    exit 1
fi
TEX_FILE_PATH="$GIT_ROOT_DIR/CUM_report/commit_log.tex"

# Check if the LaTeX log file exists, if not, recreate it.
if [ ! -f "$TEX_FILE_PATH" ]; then
    echo "‚ö†Ô∏è Hook Warning: LaTeX log file not found at $TEX_FILE_PATH. Recreating it." >&2
    # Ensure the directory exists
    mkdir -p "$(dirname "$TEX_FILE_PATH")"
    # Create the file with the initial template
    cat << EOF_INNER > "$TEX_FILE_PATH"
\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{parskip}
\\usepackage{hyperref}
\\usepackage[T1]{fontenc}
\\usepackage{lmodern}
\\usepackage{amsmath}
\\usepackage{courier}

\\title{Commit Summary Report (CUM Report)}
\\author{Generated by Git Post-Commit Hook}
\\date{\\today}

\\begin{document}
\\maketitle
\\begin{abstract}
This document contains summaries of commits, generated automatically after each commit and included herein.
\\end{abstract}
\\tableofcontents
\\newpage

\\section{Introduction}
This document provides a log of commit summaries. Each section corresponds to a summary generated at the time of a commit.
The summaries are generated by an AI model based on the diff of the commit.

\\end{document}
EOF_INNER
    if [ $? -ne 0 ]; then
        echo "‚ùå Hook Error: Failed to recreate LaTeX log file at $TEX_FILE_PATH. Summary will not be added." >&2
        exit 0 # Exit gracefully, don't block commit if recreation fails
    fi
    echo "‚úÖ LaTeX log file recreated at $TEX_FILE_PATH."
fi

commit_hash=$(git rev-parse HEAD)
commit_short_hash=$(git rev-parse --short HEAD)
commit_author=$(git log -1 --pretty=format:'%an' HEAD)
commit_date=$(git log -1 --pretty=format:'%ad' --date=iso-local HEAD)

echo "üîé Analyzing commit: $commit_short_hash by $commit_author on $commit_date"

if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
    diff_output_raw=$(git diff HEAD^ HEAD --pretty=format:)
else
    diff_output_raw=$(git show --pretty=format: HEAD)
fi

if [ -z "$diff_output_raw" ]; then
  echo "‚ö†Ô∏è No textual changes found in commit $commit_short_hash to summarize. Skipping API call."
  exit 0
fi

sanitized_diff=$(echo "$diff_output_raw" | tr -d '\b\f') # Remove backspace & form-feed

MAX_DIFF_CHARS=10000 # Tunable: adjust if LLM is stable with more, or unstable with this
truncated_diff=$(echo "$sanitized_diff" | head -c "$MAX_DIFF_CHARS")

diff_to_send="$truncated_diff"
sanitized_diff_len=$(echo -n "$sanitized_diff" | wc -c)

if [ "$sanitized_diff_len" -gt "$MAX_DIFF_CHARS" ]; then
    diff_to_send+=$'\n\n[Diff truncated due to length]'
    echo "‚ö†Ô∏è Diff was truncated from $sanitized_diff_len bytes to $MAX_DIFF_CHARS characters before sending to LLM."
fi

prompt_text="Summarize the following code changes from commit $commit_short_hash. Explain what the changes likely achieve at a high level and their potential impact or purpose:\n\n$diff_to_send"

VLLM_API_URL="http://10.16.246.2:8001/v1/chat/completions"
MODEL_NAME="deepseek-ai/deepseek-moe-16b-chat" # Or your chosen alternative
MAX_TOKENS=700

echo "üìû Contacting LLM API at $VLLM_API_URL for summary..."
payload=$(jq -n \
              --arg model_name "$MODEL_NAME" \
              --arg user_prompt "$prompt_text" \
              --argjson max_tokens "$MAX_TOKENS" \
              '{
                model: $model_name,
                messages: [
                  {role: "user", content: $user_prompt}
                ],
                max_tokens: $max_tokens,
                stream: false
              }')

if [ $? -ne 0 ]; then
    echo "‚ùå Hook Error: Failed to construct JSON payload with jq." >&2
    exit 0
fi

api_response=$(curl --silent --fail --show-error -X POST \
  -H "Content-Type: application/json" \
  -d "$payload" \
  --connect-timeout 15 \
  --max-time 120 \
  "$VLLM_API_URL")
curl_exit_status=$?

summary_text=""

if [ $curl_exit_status -ne 0 ]; then
  echo "‚ùå Hook Warning: Failed to connect to LLM API or API returned an error (curl code: $curl_exit_status)." >&2
  echo "   URL: $VLLM_API_URL. Commit will proceed without summary." >&2
  summary_text="Automated summary generation failed: LLM API request error (curl code: $curl_exit_status)."
else
  extracted_text=$(echo "$api_response" | jq -r '.choices[0].message.content // ""')

  if [ -n "$extracted_text" ]; then
    summary_text="$extracted_text"
    echo -e "‚úÖ Commit summary received from LLM."
  else
    echo "‚ùå Hook Warning: Failed to extract summary from LLM response or response was empty/null." >&2
    echo "   Raw API Response (first 500 chars): $(echo "$api_response" | head -c 500)" >&2
    summary_text="Automated summary generation failed: Could not parse LLM response or response was empty/null."
  fi
fi

summary_text_for_latex=$(echo "$summary_text" | sed 's/\f//g') # Clean for LaTeX

escaped_summary=$(echo "$summary_text_for_latex" | sed \
  -e 's/\\/\\textbackslash{}/g' \
  -e 's/{/\\{/g'  -e 's/}/\\}/g' \
  -e 's/\$/\\\$/g' -e 's/&/\\&/g' \
  -e 's/#/\\#/g'  -e 's/_/\\_/g' \
  -e 's/%/\\%/g'  -e 's/~/\\textasciitilde{}/g' \
  -e 's/\^/\\^{}/g' \
  -e 's/</\\textless{}/g' -e 's/>/\\textgreater{}/g' \
  -e 's/-/--/g')

escaped_commit_author=$(echo "$commit_author" | sed 's/[&%$_#]/\_&/g; s/_/\\_/g')
escaped_commit_date=$(echo "$commit_date" | sed 's/_/\\_/g')

section_title="Commit $commit_short_hash by $escaped_commit_author ($escaped_commit_date)"

section_content="\\section{$section_title}
\\subsection{AI Generated Summary}
{\\fontfamily{pcr}\\selectfont
$escaped_summary
}
\\subsection{Commit Details}
\\begin{itemize}
    \\item \\textbf{Commit Hash:} $commit_hash
    \\item \\textbf{Author:} $escaped_commit_author
    \\item \\textbf{Date:} $escaped_commit_date
\\end{itemize}
\\hrulefill
"
TMP_TEX_FILE="$GIT_ROOT_DIR/CUM_report/tmp_commit_log.$$.tex"

export CUM_REPORT_AWK_SECTION_CONTENT="$section_content"

awk '/\\end\{document\}/{printf "%s\n", ENVIRON["CUM_REPORT_AWK_SECTION_CONTENT"]}1' "$TEX_FILE_PATH" > "$TMP_TEX_FILE"
awk_status=$?

unset CUM_REPORT_AWK_SECTION_CONTENT

if [ $awk_status -eq 0 ]; then
    mv "$TMP_TEX_FILE" "$TEX_FILE_PATH"
    if [ $? -eq 0 ]; then
        echo "‚úÖ Summary for commit $commit_short_hash appended to $TEX_FILE_PATH"
        echo " amending commit to include this change..."
        git add "$TEX_FILE_PATH"
        export GIT_CUM_REPORT_AMENDING_COMMIT=true
        git commit --amend --no-edit -C HEAD
        unset GIT_CUM_REPORT_AMENDING_COMMIT
        echo "‚úÖ Commit amended to include TeX log update."
    else
        echo "‚ùå Hook Warning: Failed to move temporary TeX file. TeX log not updated." >&2
        rm -f "$TMP_TEX_FILE"
    fi
else
    echo "‚ùå Hook Warning: Failed to write summary to TeX file using awk (status: $awk_status). TeX log not updated." >&2
    rm -f "$TMP_TEX_FILE"
fi

echo "‚úÖ CUM post-commit hook finished for $commit_short_hash."
exit 0
HOOK_SCRIPT_EOF

if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to write post-commit hook script content to $HOOK_PATH." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook content successfully written to $HOOK_PATH."
echo "Checkpoint 11: Hook content written."

if [ ! -s "$HOOK_PATH" ]; then
    echo "‚ùå CRITICAL Error: Hook file $HOOK_PATH was NOT created or is EMPTY." >&2
    exit 1
fi
echo "‚úÖ Hook file $HOOK_PATH exists and is not empty."
echo "Checkpoint 12: Hook file verified (exists and not empty)."

chmod +x "$HOOK_PATH"
if [ $? -ne 0 ]; then
    echo "‚ùå CRITICAL Error: Failed to make hook script $HOOK_PATH executable." >&2
    exit 1
fi
echo "‚úÖ Post-commit hook made executable at $HOOK_PATH."
echo "Checkpoint 13: Hook made executable."

echo "üéâ CUM Report setup complete with a post-commit hook!"
echo "After each 'git commit', the summary will be generated and the commit will be amended to include the changes to '$INITIAL_TEX_FILE'."
echo "Your working directory should remain clean regarding this file after a commit."
echo "To view the report, compile '$INITIAL_TEX_FILE' (e.g., using 'pdflatex $INITIAL_TEX_FILE' in the '$CUM_REPORT_DIR' directory)."
echo ""
echo "If the hook doesn't run after 'git commit', check 'git config core.hooksPath'."
echo "Script execution finished at: $(date)"

exit 0
